---
title: "Compaction API 压缩接口"
description: "关于 Compaction API 的常见问题：是什么、何时使用、与上下文窗口的对比"
date: 2026-02-10
lang: zh
slug: compaction-api
keywords:
  - "Compaction API 压缩"
  - "上下文摘要"
  - "AI 无限对话"
---

### 什么是 Compaction API？

Compaction API 是随 Claude Opus 4.6 推出的功能，通过服务端上下文总结实现无限对话。当对话接近上下文窗口限制时，API 将较早的对话轮次压缩为紧凑的摘要，同时保留关键信息。

工作流程：
1. 正常发送对话历史
2. 历史接近上下文限制时，API 总结较早的轮次
3. 压缩后的上下文替代完整历史
4. 新消息加入压缩后的上下文
5. 模型保留核心信息，无需逐字记录

这解决了固定大小上下文窗口的根本问题：没有压缩，长对话会触达限制并丢失所有早期上下文。

---

### 什么时候应该使用 Compaction API？

适合使用的场景：

* **长编程会话**：持续数小时或数天的代理工作流
* **持久聊天机器人**：有持续对话的客服或助手
* **迭代开发**：代码或文档的长时间反复修改
* **研究会话**：基于早期发现层层递进的长分析对话

不适合的场景：
* 对话在上下文窗口内就能完成
* 需要逐字回忆早期消息
* 早期上下文是结构化数据（表格、配置），总结可能丢失精度

最佳场景是对话会超出上下文窗口，且对早期轮次的近似回忆已经足够的情况。

---

### Compaction API 与大上下文窗口：该用哪个？

两者是互补关系，而非竞争：

| | 大上下文窗口 | Compaction API |
|---|---|---|
| **方式** | 一次性放入所有内容 | 总结旧上下文腾出空间 |
| **成本** | 随历史长度线性增长 | 历史增长但成本有上限 |
| **信息丢失** | 无（完整逐字） | 有（经过总结） |
| **适合** | < 100 万 token 的对话 | > 100 万 token 的对话 |

**最优策略**：先使用完整上下文窗口，接近限制时启用压缩。最近的上下文保持最大保真度，较早的轮次获得总结回忆。

---

### 压缩如何影响回复质量？

压缩在上下文长度和信息保真度之间引入权衡：

* **保留良好的**：关键决策、重要事实、用户偏好、主要话题、代码架构决策
* **可能丢失的**：精确措辞、细枝末节、微妙讨论要点、对话早期提到的具体数字
* **始终保留的**：最近的对话轮次（永不被压缩）

实践中，大多数场景下质量下降微乎其微。对于需要持久保存的关键信息，建议显式重述或存入文件，而非仅依赖对话上下文。

---

### Compaction API 的成本是多少？

成本包含两部分：

1. **压缩调用**：通过总结模型处理 token 的费用
2. **后续成本降低**：压缩后每次 API 调用处理的输入 token 更少

对于超过 100 万 token 的对话，压缩通常比截断或重启上下文的方案**节省 50-80%**。

无压缩时，成本随对话长度线性增长。有压缩时，无论总对话长度如何，每次调用处理约 20-50 万 token，成本保持可控。

---

### 可以控制 Compaction API 保留什么吗？

可以引导压缩行为：

* **系统提示永不压缩**：你的系统指令始终完整保留
* **固定消息**：标记特定消息为重要，以逐字保留
* **压缩指令**：在系统提示中说明哪些信息最重要
* **自定义总结**：高级场景可以实现自己的压缩逻辑

示例：在系统提示中添加"压缩上下文时，始终保留用户名称和偏好、关键架构决策、讨论过的文件路径和函数名"。

---

### Compaction API 与手动总结相比如何？

| | Compaction API | 手动总结 |
|---|---|---|
| 工作量 | 自动 | 需要自定义代码 |
| 质量 | 通用良好 | 可针对领域定制 |
| 控制度 | 系统提示引导 | 完全控制保留内容 |
| 一致性 | 标准化 | 因实现而异 |

大多数应用使用 Compaction API 即可。当有领域特定的保留需求、需要结构化摘要、或要与外部记忆系统集成时，手动总结值得投入。

---

### Compaction API 与 Agent Teams 配合使用吗？

是的，对 Agent Teams 特别有价值：

* **长时间运行的代理**：团队中的代理可能运行数小时；压缩保持上下文可管理
* **代理交接**：一个代理向另一个交接时，压缩上下文可作为简报
* **主导代理上下文**：协调代理积累所有工作者的状态更新；压缩防止上下文溢出

没有压缩，处理复杂项目的 Agent Teams 会频繁触达上下文限制，需要重启并丢失积累的知识。

---

### Compaction API 有哪些替代方案？

如果不使用 Claude 的 Compaction API：

* **基于 RAG 的记忆**：将对话存入向量数据库，按需检索相关内容
* **滑动窗口**：只保留最近 N 轮，丢弃更早的（粗糙但简单）
* **手动总结**：定期调用 LLM 总结对话历史
* **外部记忆**：将重要事实存入数据库或文件
* **混合方案**：滑动窗口 + 定期总结检查点

Compaction API 的优势在于内置、自动、针对 Claude 架构优化。使用替代方案的主要原因是需要跨模型兼容或专门的记忆结构。

---

### 如何在应用中集成 Compaction API？

集成过程简单直接：

1. 在 API 配置中**启用压缩**
2. **正常发送消息**——API 在需要时自动处理压缩
3. **监控压缩事件**——API 在发生压缩时返回元数据
4. **优雅处理**——应用应预期非常早期的上下文可能已被总结

关键实现考虑：根据场景设置压缩阈值（如在上下文限制的 80% 时压缩）、记录压缩事件以便调试、用长对话测试验证重要信息是否保留、考虑将关键数据存储在外部而非仅依赖对话上下文。
